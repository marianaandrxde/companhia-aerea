
/*
 ========================================
 ||                                    ||
 ||    Trigger para Validar Usuario    ||
 ||                                    ||
 ========================================
 */

CREATE OR REPLACE FUNCTION T_VALIDACAO_USUARIO()
RETURNS TRIGGER AS $$
BEGIN 
    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
        PERFORM VALIDAR_EMAIL(NEW.EMAIL);
        PERFORM VALIDAR_TELEFONE(NEW.TELEFONE);
        PERFORM VALIDAR_CPF(NEW.CPF);

        IF EXISTS (SELECT 1 FROM USUARIO WHERE EMAIL = NEW.EMAIL AND ID_USUARIO <> NEW.ID_USUARIO) THEN
            RAISE EXCEPTION 'Email já cadastrado em outro usuário';
        END IF;

        IF EXISTS (SELECT 1 FROM USUARIO WHERE CPF = NEW.CPF AND ID_USUARIO <> NEW.ID_USUARIO) THEN
            RAISE EXCEPTION 'CPF já cadastrado com outro usuário';
        END IF;

        IF (NEW.CPF IS NULL OR NEW.NOME IS NULL OR NEW.DT_NASC IS NULL OR NEW.EMAIL IS NULL OR NEW.ENDERECO IS NULL OR NEW.TELEFONE IS NULL) THEN 
            RAISE EXCEPTION 'Valores nulos';
        END IF;

        RETURN NEW;

    ELSIF (TG_OP = 'DELETE') THEN
		PERFORM PRIVATE_VERIFICAR_USUARIO(OLD.ID_USUARIO);

        IF EXISTS (SELECT * FROM ITEM_RESERVA IR 
            JOIN RESERVA R ON R.ID_RESERVA = IR.ID_RESERVA
            WHERE R.ID_USUARIO = OLD.ID_USUARIO 
            AND IR.ID_VOO IS NOT NULL
            AND EXISTS (SELECT 1 FROM VOO V WHERE V.ID_VOO = IR.ID_VOO AND V.DATA_VOO > CURRENT_DATE)) THEN 
            RAISE EXCEPTION 'NÃO É POSSÍVEL DELETAR USUÁRIO ASSOCIADO A VOO NÃO REALIZADO';
        END IF;

		UPDATE USUARIO SET ATIVO = FALSE WHERE ID_USUARIO = OLD.ID_USUARIO;
			RAISE NOTICE 'USUARIO REMOVIDO';
    END IF;

    RETURN NULL; 
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER TRIGGER_VALIDACAO_USUARIO 
BEFORE INSERT OR UPDATE OR DELETE ON USUARIO FOR EACH ROW EXECUTE PROCEDURE T_VALIDACAO_USUARIO();

/*
 ========================================
 ||                                    ||
 ||    Função para Pagar Reserva       ||
 ||                                    ||
 ========================================
 */

 CREATE OR REPLACE FUNCTION REALIZAR_PAGAMENTO(_ID_RESERVA INT)
 RETURNS VOID AS $$
 BEGIN
 	UPDATE RESERVA SET PAGO = TRUE WHERE ID_RESERVA = _ID_RESERVA;
	 RAISE NOTICE 'PAGAMENTO DA RESERVA EFETUADO';
 END;
 $$ LANGUAGE PLPGSQL;

/*
 ========================================
 ||                                      ||
 ||        Trigger para Validar          ||
 ||               Reserva                ||
 ||                                      ||
 ========================================
 */
CREATE OR REPLACE FUNCTION T_VALIDACAO_RESERVA()
RETURNS TRIGGER AS $$
BEGIN
    -- No insert, verifica se os valores são inválidos e inicializa valor com 0
    IF (TG_OP = 'INSERT') THEN
        IF NEW.DATA_RESERVA IS NULL OR NEW.ID_USUARIO IS NULL THEN
            RAISE EXCEPTION 'Valores nulos';
        END IF;

		PERFORM PRIVATE_VERIFICAR_USUARIO(NEW.ID_USUARIO);
        NEW.VALOR_TOTAL_RESERVA := 0;
        RETURN NEW;

    -- No update, impede a troca de titularidade da reserva
    ELSIF (TG_OP = 'UPDATE') THEN
        IF (NEW.ID_USUARIO != OLD.ID_USUARIO) THEN
            RAISE EXCEPTION 'NÃO É POSSÍVEL TROCAR A TITULARIDADE DA RESERVA';
        END IF;

    -- No delete, impede a exclusão se existe algum voo relacionado que já ocorreu
    -- Se não, exclui
    ELSIF (TG_OP = 'DELETE') THEN
        IF EXISTS (SELECT 1 FROM ITEM_RESERVA IR
                    JOIN RESERVA R ON IR.ID_RESERVA = R.ID_RESERVA 
                    JOIN VOO V ON IR.ID_VOO = V.ID_VOO
                    WHERE R.ID_RESERVA = OLD.ID_RESERVA 
                    AND V.DATA_VOO < CURRENT_DATE) THEN
            RAISE EXCEPTION 'NÃO É POSSÍVEL A DESVINCULAÇÃO DE VOOS OCORRIDOS';	
        ELSE 
            -- Atualiza o status dos assentos relacionados
            UPDATE AVIAO_ASSENTO_CLASSE_VOO AACV
            SET STATUS = FALSE
            WHERE AACV.ID_AVIAO_ASSENTO_CLASSE_VOO IN (
                SELECT IR.ID_AVIAO_ASSENTO_CLASSE_VOO
                FROM ITEM_RESERVA IR
                WHERE IR.ID_RESERVA = OLD.ID_RESERVA
            );

            -- Exclui os itens de reserva
            DELETE FROM ITEM_RESERVA WHERE ID_RESERVA = OLD.ID_RESERVA;
        END IF;
        RETURN OLD;  
    END IF;
    RETURN NULL; 
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGGER_VALIDACAO_RESERVA
BEFORE INSERT OR DELETE ON RESERVA
FOR EACH ROW EXECUTE FUNCTION T_VALIDACAO_RESERVA();
/*
 ========================================
 ||                                    ||
 ||Trigger para Validar Item da Reserva||
 ||                                    ||
 ========================================
 */

CREATE OR REPLACE FUNCTION T_VALIDACAO_ITEM_DA_RESERVA() 
RETURNS TRIGGER AS $$ 
DECLARE VALOR_TRAJETO NUMERIC(10, 2);
VALOR_CLASSE NUMERIC(10, 2);
ID_AVIAO_DO_VOO INT;
BEGIN 
    PERFORM VALIDAR_CPF(NEW.CPF_PASSAGEIRO);
	PERFORM PRIVATE_VERIFICAR_VOO(NEW.ID_VOO);
	PERFORM PRIVATE_VERIFICAR_RESERVA(NEW.ID_RESERVA);
	PERFORM PRIVATE_VERIFICAR_STATUS_DO_PAGAMENTO(NEW.ID_RESERVA);

	SELECT ID_AVIAO INTO ID_AVIAO_DO_VOO 
	FROM AVIAO NATURAL JOIN AVIAO_ASSENTO_CLASSE_VOO AACV
	WHERE ID_AVIAO = AACV.ID_AVIAO AND AACV.ID_AVIAO_ASSENTO_CLASSE_VOO = NEW.ID_AVIAO_ASSENTO_CLASSE_VOO;
	
	PERFORM PRIVATE_VERIFICAR_ASSENTO(NEW.ID_AVIAO_ASSENTO_CLASSE_VOO, NEW.ID_VOO,ID_AVIAO_DO_VOO);
	
	IF (NEW.ID_VOO != (SELECT ID_VOO FROM AVIAO_ASSENTO_CLASSE_VOO 
	WHERE ID_AVIAO_ASSENTO_CLASSE_VOO = NEW.ID_AVIAO_ASSENTO_CLASSE_VOO)) THEN
		RAISE EXCEPTION 'NAO É POSSIVEL SE ASSOCIAR A 1 ASSENTO REFERENTE A OUTRO VOO';
	END IF;

	IF EXISTS (SELECT 1 FROM AVIAO_ASSENTO_CLASSE_VOO WHERE ID_AVIAO_ASSENTO_CLASSE_VOO = NEW.ID_AVIAO_ASSENTO_CLASSE_VOO AND ( ID_VOO = NEW.ID_VOO AND STATUS = TRUE)) THEN
	    RAISE EXCEPTION 'NÃO FOI POSSÍVEL RESERVAR O ASSENTO, POIS ESTÁ OCUPADO';
	END IF;
	
    SELECT COALESCE(T.VALOR_TRAJETO, 0) INTO VALOR_TRAJETO FROM TRAJETO T
    JOIN VOO V ON T.ID_TRAJETO = V.ID_TRAJETO
    WHERE
    V.ID_VOO = NEW.ID_VOO;

    SELECT COALESCE(C.VALOR, 0)
    INTO VALOR_CLASSE
    FROM   CLASSE C
    JOIN AVIAO_ASSENTO_CLASSE_VOO AAC ON AAC.ID_CLASSE = C.ID_CLASSE
    WHERE AAC.ID_AVIAO_ASSENTO_CLASSE_VOO = NEW.ID_AVIAO_ASSENTO_CLASSE_VOO;

    NEW.VALOR := VALOR_TRAJETO + VALOR_CLASSE;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGGER_VALIDACAO_ITEM_DA_RESERVA BEFORE
INSERT ON ITEM_RESERVA FOR EACH ROW EXECUTE PROCEDURE T_VALIDACAO_ITEM_DA_RESERVA();

CREATE OR REPLACE FUNCTION T_CONTROLAR_ALTERACOES_ITEM_RESERVA() 
RETURNS TRIGGER AS $$ 
DECLARE VALOR_TRAJETO NUMERIC(10, 2);
VALOR_CLASSE NUMERIC(10, 2);
ID_AVIAO_DO_VOO INT;
BEGIN 
    PERFORM VALIDAR_CPF(NEW.CPF_PASSAGEIRO);
	PERFORM PRIVATE_VERIFICAR_RESERVA(NEW.ID_RESERVA);
	
	SELECT ID_AVIAO INTO ID_AVIAO_DO_VOO 
	FROM AVIAO NATURAL JOIN AVIAO_ASSENTO_CLASSE_VOO AACV
	WHERE ID_AVIAO = AACV.ID_AVIAO AND AACV.ID_AVIAO_ASSENTO_CLASSE_VOO = NEW.ID_AVIAO_ASSENTO_CLASSE_VOO;

	PERFORM PRIVATE_VERIFICAR_ASSENTO(NEW.ID_AVIAO_ASSENTO_CLASSE_VOO, ID_AVIAO_DO_VOO);

	IF (NEW.ID_RESERVA != OLD.ID_RESERVA) THEN
		RAISE EXCEPTION 'NAO É POSSIVEL TROCAR A TITULARIDADE DA RESERVA';
	END IF;

	IF (NEW.ID_VOO != OLD.ID_VOO) THEN
		RAISE EXCEPTION 'NAO É POSSIVEL TROCAR O VOO! REALIZE OUTRA RESERVA.';
	END IF;

	IF (NEW.VALOR != OLD.VALOR AND NEW.ID_AVIAO_ASSENTO_CLASSE_VOO = OLD.ID_AVIAO_ASSENTO_CLASSE_VOO) THEN
		RAISE EXCEPTION 'NÃO É POSSIVEL ALTERAR VALOR DA PASSAGEM SE A CLASSE DO ASSENTO NÃO MUDAR';
	END IF;

	IF(NEW.ID_AVIAO_ASSENTO_CLASSE_VOO != OLD.ID_AVIAO_ASSENTO_CLASSE_VOO) THEN
		SELECT COALESCE(T.VALOR_TRAJETO, 0) INTO VALOR_TRAJETO FROM TRAJETO T
    	JOIN VOO V ON T.ID_TRAJETO = V.ID_TRAJETO
    	WHERE V.ID_VOO = NEW.ID_VOO;

    	SELECT COALESCE(C.VALOR, 0)
    	INTO VALOR_CLASSE
    	FROM   CLASSE C
    	JOIN AVIAO_ASSENTO_CLASSE_VOO AAC ON AAC.ID_CLASSE = C.ID_CLASSE
    	WHERE AAC.ID_AVIAO_ASSENTO_CLASSE_VOO = NEW.ID_AVIAO_ASSENTO_CLASSE_VOO;

    	NEW.VALOR := VALOR_TRAJETO + VALOR_CLASSE;
	END IF;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGGER_CONTROLE_ALTERACOES_ITEM_RESERVA BEFORE
UPDATE ON ITEM_RESERVA FOR EACH ROW EXECUTE FUNCTION T_CONTROLAR_ALTERACOES_ITEM_RESERVA();
/*
 ========================================
 ||                                    ||
 ||     Trigger para Validar Voo       ||
 ||                                    ||
 ========================================
 */

CREATE OR REPLACE FUNCTION T_VALIDACAO_VOO() 
RETURNS TRIGGER AS $$ 
DECLARE ID_ORIGEM_OLD INT;
ID_DESTINO_OLD INT;
ID_ORIGEM_NEW INT;
ID_DESTINO_NEW INT;
BEGIN 
	PERFORM PRIVATE_VERIFICAR_TRAJETO(NEW.ID_TRAJETO);
	PERFORM PRIVATE_VERIFICAR_AVIAO(NEW.ID_AVIAO);
	
	IF(TG_OP = 'INSERT') THEN
		IF(NEW.DATA_VOO < CURRENT_DATE) THEN
			RAISE EXCEPTION 'DATA INVÁLIDA';
		END IF;

	ELSIF (TG_OP = 'UPDATE') THEN
		IF(NEW.DATA_VOO < CURRENT_DATE OR (OLD.DATA_VOO < CURRENT_DATE AND NEW.DATA_VOO > CURRENT_DATE)) THEN
			RAISE EXCEPTION 'NAO É POSSIVEL MODIFICAR A DATA DE UM VOO JÁ REALIZADO';
		END IF;

		SELECT ID_ORIGEM, ID_DESTINO INTO ID_ORIGEM_OLD, ID_DESTINO_OLD
		FROM CIDADE C
		NATURAL JOIN TRAJETO T
		NATURAL JOIN VOO 
		WHERE ID_TRAJETO = OLD.ID_TRAJETO;

		SELECT ID_ORIGEM, ID_DESTINO INTO ID_ORIGEM_NEW, ID_DESTINO_NEW
		FROM CIDADE C
		NATURAL JOIN TRAJETO T
		NATURAL JOIN VOO 
		WHERE ID_TRAJETO = NEW.ID_TRAJETO;

		IF (ID_ORIGEM_OLD != ID_ORIGEM_NEW OR ID_DESTINO_OLD != ID_DESTINO_NEW) THEN
			RAISE EXCEPTION 'NÃO É POSSÍVEL ALTERAR AS CIDADES RELACIONADAS AO VOO';
		END IF;
	END IF;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGGER_VALIDACAO_VOO BEFORE
INSERT OR UPDATE ON VOO FOR EACH ROW EXECUTE PROCEDURE T_VALIDACAO_VOO();


/*
 ========================================
 ||                                    ||
 || Trigger para Controlar Aviao       ||
 ||                                    ||
 ========================================
 */
 
CREATE OR REPLACE FUNCTION T_CONTROLAR_AVIAO() 
RETURNS TRIGGER AS $$ 
BEGIN 
	IF (TG_OP = 'DELETE') THEN
		IF EXISTS (SELECT 1 FROM VOO NATURAL JOIN AVIAO 
			WHERE ID_AVIAO = OLD.ID_AVIAO 
			AND (DATA_VOO >= CURRENT_DATE AND HORARIO_SAIDA > CURRENT_TIME)) THEN
			RAISE EXCEPTION 'NAO É POSSIVEL DELETAR VOO POIS EXISTEM VOOS ASSOCIADOS';
		END IF;
		
		UPDATE AVIAO SET ATIVO = FALSE WHERE ID_AVIAO = OLD.ID_AVIAO;  
		RAISE NOTICE 'AVIÃO REMOVIDO';
		RETURN OLD; 
		
	ELSIF (TG_OP = 'UPDATE') THEN
		IF (NEW.ID_AVIAO != OLD.ID_AVIAO) THEN
			RAISE EXCEPTION 'NÃO É POSSÍVEL ALTERAR IDENTIFICADOR DO AVIAO';
		END IF;
		RETURN NEW;  
	ELSIF(TG_OP = 'INSERT') THEN
		RETURN NEW;
	END IF;

	RETURN NULL;  
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGGER_CONTROLE_AVIAO BEFORE
INSERT OR UPDATE OR DELETE ON AVIAO FOR EACH ROW EXECUTE PROCEDURE T_CONTROLAR_AVIAO();


/*
 ========================================
 ||                                    ||
 ||     Trigger para Validar Voo       ||
 ||                                    ||
 ========================================
 */

CREATE OR REPLACE FUNCTION T_CONTROLAR_CLASSE() 
RETURNS TRIGGER AS $$ 
BEGIN 
	IF (TG_OP = 'DELETE') THEN
		RAISE EXCEPTION 'NÃO É POSSÍVEL DELETAR CLASSE!';
		
	ELSIF (TG_OP = 'INSERT') THEN
		IF (NEW.VALOR = 0) THEN
			RAISE EXCEPTION 'CLASSE NAO PODE SER INICIALIZADA COM 0';
		END IF;
		
	ELSIF (TG_OP = 'UPDATE') THEN
		IF (NEW.VALOR < 0.5 * OLD.VALOR) THEN
			RAISE EXCEPTION 'REDUÇÃO DE VALOR EXACERBADA!';
		END IF;
	END IF;

	RETURN NEW;  
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE TRIGGER TRIGGER_CONTROLE_CLASSE BEFORE
INSERT OR UPDATE OR DELETE ON CLASSE FOR EACH ROW EXECUTE PROCEDURE T_CONTROLAR_CLASSE();

/*
 ========================================
 ||        Trigger para Atualizar        ||
 ||          Status do Assento           ||
 ||           Após a Reserva             ||
 ========================================
 */

CREATE OR REPLACE FUNCTION T_ATUALIZAR_STATUS_DO_ASSENTO()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        UPDATE AVIAO_ASSENTO_CLASSE_VOO 
        SET STATUS = TRUE 
        WHERE ID_AVIAO_ASSENTO_CLASSE_VOO = NEW.ID_AVIAO_ASSENTO_CLASSE_VOO;
        RETURN NEW;

    ELSIF (TG_OP = 'UPDATE') THEN
        UPDATE AVIAO_ASSENTO_CLASSE_VOO 
        SET STATUS = FALSE 
        WHERE ID_AVIAO_ASSENTO_CLASSE_VOO = OLD.ID_AVIAO_ASSENTO_CLASSE_VOO;
		
        UPDATE AVIAO_ASSENTO_CLASSE_VOO 
        SET STATUS = TRUE 
        WHERE ID_AVIAO_ASSENTO_CLASSE_VOO = NEW.ID_AVIAO_ASSENTO_CLASSE_VOO;
        RETURN NEW;

    ELSIF (TG_OP = 'DELETE') THEN
        UPDATE AVIAO_ASSENTO_CLASSE_VOO 
        SET STATUS = FALSE 
        WHERE ID_AVIAO_ASSENTO_CLASSE_VOO = OLD.ID_AVIAO_ASSENTO_CLASSE_VOO;
        RETURN OLD;  
    END IF;

    RETURN NULL;  
END;
$$ LANGUAGE PLPGSQL;

CREATE
OR REPLACE TRIGGER TRIGGER_ATUALIZACAO_STATUS_DO_ASSENTO AFTER
INSERT OR UPDATE OR DELETE ON ITEM_RESERVA FOR EACH ROW EXECUTE PROCEDURE T_ATUALIZAR_STATUS_DO_ASSENTO();

/*
 ========================================
 ||                                      ||
 ||        Trigger para Atualizar        ||
 ||          Valor da Reserva            ||
 ||                                      ||
 ========================================
 */
 
CREATE OR REPLACE FUNCTION ATUALIZAR_VALOR_TOTAL_RESERVA()
RETURNS TRIGGER AS $$
BEGIN
	IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
		UPDATE RESERVA 
		SET VALOR_TOTAL_RESERVA = (
			SELECT SUM(COALESCE(VALOR, 0))
			FROM ITEM_RESERVA
			WHERE ID_RESERVA = NEW.ID_RESERVA
		)
		WHERE ID_RESERVA = NEW.ID_RESERVA;  
		RETURN NEW;
	ELSE
		UPDATE RESERVA
		SET VALOR_TOTAL_RESERVA = (
			SELECT SUM(COALESCE(VALOR, 0))
			FROM ITEM_RESERVA
			WHERE ID_RESERVA = OLD.ID_RESERVA
		)
		WHERE ID_RESERVA = OLD.ID_RESERVA;  
		RETURN OLD;
	END IF;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER T_ATUALIZACAO_VALOR_TOTAL_RESERVA AFTER INSERT OR UPDATE OR DELETE ON
ITEM_RESERVA FOR EACH ROW EXECUTE FUNCTION ATUALIZAR_VALOR_TOTAL_RESERVA();


/*
 ========================================
 ||                                      ||
 ||        Trigger para Atualizar        ||
 ||          Valor do trajeto            ||
 ||                                      ||
 ========================================
 */
 
CREATE OR REPLACE FUNCTION ATUALIZAR_VALOR_TOTAL_TRAJETO()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'UPDATE') THEN
        UPDATE TRAJETO
        SET VALOR_TRAJETO = (DISTANCIA_KM * (SELECT VALOR FROM CUSTO_KM WHERE ID_CUSTO_KM = NEW.ID_CUSTO_KM))WHERE ID_CUSTO_KM = NEW.ID_CUSTO_KM;

        RETURN NEW;  
    END IF;

    IF (TG_OP = 'DELETE') THEN
        RAISE EXCEPTION 'NAO É POSSIVEL DELETAR CUSTO';
    END IF;

    RETURN NULL; 
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER T_ATUALIZACAO_VALOR_TOTAL_TRAJETO
AFTER UPDATE OR DELETE ON CUSTO_KM
FOR EACH ROW EXECUTE FUNCTION ATUALIZAR_VALOR_TOTAL_TRAJETO();


/*
 ========================================
 ||                                      ||
 ||        Trigger para Atualizar        ||
 ||          Valor da Reserva            ||
 ||                                      ||
 ========================================
 */
 
CREATE OR REPLACE FUNCTION ATUALIZAR_VALOR_TOTAL_RESERVA()
RETURNS TRIGGER AS $$
BEGIN
	IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
		UPDATE RESERVA 
		SET VALOR_TOTAL_RESERVA = (
			SELECT SUM(COALESCE(VALOR, 0))
			FROM ITEM_RESERVA
			WHERE ID_RESERVA = NEW.ID_RESERVA
		)
		WHERE ID_RESERVA = NEW.ID_RESERVA;  
		RETURN NEW;
	ELSE
		UPDATE RESERVA
		SET VALOR_TOTAL_RESERVA = (
			SELECT SUM(COALESCE(VALOR, 0))
			FROM ITEM_RESERVA
			WHERE ID_RESERVA = OLD.ID_RESERVA
		)
		WHERE ID_RESERVA = OLD.ID_RESERVA;  
		RETURN OLD;
	END IF;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER T_ATUALIZACAO_VALOR_TOTAL_RESERVA AFTER INSERT OR UPDATE OR DELETE ON
ITEM_RESERVA FOR EACH ROW EXECUTE FUNCTION ATUALIZAR_VALOR_TOTAL_RESERVA();

/*
 ========================================
 ||                                    ||
 ||   Trigger para Validar Trajeto     ||
 ||                                    ||
 ========================================
 */

CREATE OR REPLACE FUNCTION T_VALIDACAO_TRAJETO()
RETURNS TRIGGER AS $$
DECLARE KILOMETRAGEM INT;
BEGIN 
	IF(TG_OP = 'INSERT') THEN
	    IF NOT EXISTS (SELECT 1 FROM CUSTO_KM WHERE KM >= NEW.DISTANCIA_KM) THEN 
		    RAISE EXCEPTION 'A Companhia não realiza voo para a distância especificada';
		END IF;
	
		IF (NEW.ID_ORIGEM = NEW.ID_DESTINO) THEN
			RAISE EXCEPTION 'NÃO É POSSIVEL RELACIONAR CIDADES IGUAIS EM UM TRAJETO';
		END IF;
	
		NEW.VALOR_TRAJETO := NEW.DISTANCIA_KM * (
	    SELECT VALOR FROM CUSTO_KM WHERE KM = (SELECT MIN(KM) FROM CUSTO_KM WHERE KM >= NEW.DISTANCIA_KM));
	
		SELECT MIN(KM) INTO KILOMETRAGEM FROM CUSTO_KM WHERE KM >= NEW.DISTANCIA_KM;
		NEW.ID_CUSTO_KM := (SELECT ID_CUSTO_KM FROM CUSTO_KM WHERE KM = KILOMETRAGEM);
		
	ELSIF(TG_OP = 'DELETE') THEN
		UPDATE TRAJETO SET ATIVO = FALSE WHERE ID_TRAJETO = OLD.ID_TRAJETO;
		RAISE NOTICE 'TRAJETO DESATIVADO';
	END IF;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGGER_VALIDACAO_TRAJETO 
BEFORE INSERT OR UPDATE OR DELETE ON TRAJETO FOR EACH ROW EXECUTE FUNCTION T_VALIDACAO_TRAJETO();

/*
 ========================================
 ||                                    ||
 ||   Trigger para Validar Custo       ||
 ||                                    ||
 ========================================
 */
 
CREATE OR REPLACE FUNCTION T_VALIDACAO_CUSTO_KM() 
RETURNS TRIGGER AS $$ 
DECLARE DISTANCIA INT;
BEGIN 
	IF (TG_OP = 'INSERT') THEN
	    IF EXISTS (SELECT 1 FROM CUSTO_KM WHERE KM = NEW.KM AND ID_CUSTO_KM <> NEW.ID_CUSTO_KM) THEN
	        RAISE EXCEPTION 'A QUILOMETRAGEM JÁ EXISTE';
	    END IF;
	END IF;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM TRAJETO;

CREATE OR REPLACE TRIGGER TRIGGER_VALIDACAO_CUSTO_KM 
BEFORE INSERT OR UPDATE ON CUSTO_KM FOR EACH ROW EXECUTE FUNCTION T_VALIDACAO_CUSTO_KM();

/*
 ========================================
 ||                                    ||
 ||     Trigger para Validar AACV      ||
 ||                                    ||
 ========================================
 */
CREATE OR REPLACE FUNCTION T_VALIDACAO_AACV()
RETURNS TRIGGER AS $$
DECLARE
	V_CAPACIDADE INTEGER;
    V_QTD_ASSENTOS INTEGER;
BEGIN
	PERFORM PRIVATE_VERIFICAR_VOO(NEW.ID_VOO);
	PERFORM PRIVATE_VERIFICAR_AVIAO(NEW.ID_AVIAO);
	PERFORM PRIVATE_VERIFICAR_CLASSE(NEW.ID_CLASSE);
	PERFORM PRIVATE_VERIFICAR_POLTRONA(NEW.ID_ASSENTO);
	
    SELECT CAPACIDADE INTO V_CAPACIDADE
    FROM AVIAO NATURAL JOIN VOO WHERE ID_AVIAO = NEW.ID_AVIAO AND ID_VOO = NEW.ID_VOO;

    SELECT COUNT(*) + 1 INTO V_QTD_ASSENTOS FROM AVIAO_ASSENTO_CLASSE_VOO
    WHERE ID_AVIAO = NEW.ID_AVIAO;

    IF V_QTD_ASSENTOS > V_CAPACIDADE THEN
    	RAISE EXCEPTION 'Não é possível adicionar. Capacidade máxima já atingida!';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER TRIGGER_VALIDACAO_AACV BEFORE INSERT OR UPDATE
ON AVIAO_ASSENTO_CLASSE_VOO FOR EACH ROW EXECUTE FUNCTION T_VALIDACAO_AACV();

/*
 ========================================
 ||                                      ||
 ||     Trigger para Bloquear            ||
 || Alteração de Valor em Item da Reserva||
 ||                                      ||
 ========================================
 */
 
CREATE OR REPLACE FUNCTION T_BLOQUEAR_ALTERACAO_VALOR_RESERVA()
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.VALOR_TOTAL_RESERVA != 
        (SELECT SUM(COALESCE(VALOR, 0)) 
         FROM ITEM_RESERVA 
         WHERE ID_RESERVA = NEW.ID_RESERVA)) THEN
        RAISE EXCEPTION 'NÃO É POSSÍVEL ATUALIZAR VALOR DA RESERVA';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGGER_BLOQUEIO_ALTERACAO_VALOR_RESERVA
BEFORE UPDATE ON RESERVA FOR EACH ROW EXECUTE PROCEDURE T_BLOQUEAR_ALTERACAO_VALOR_RESERVA();